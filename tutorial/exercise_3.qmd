---
title: "Decryption app"
author: "BIF buddy group 7"
format: html
execute:
  eval: false
  echo: true
  warning: false
  message: false
toc: true
toc-depth: 3
---

```{r setup, include=FALSE}
# For configuring options
```

# 

In this exercise you will decode an encrypted message, but before we can do so, we need to learn how to mount the docker directory to your local directory and how to pass environment variables.

# 

# Use bind mounts

Mounts are used in docker to give your container access to files on your host system and vice versa. There are three types of mount: bind mounts, volume mounts, and tmpfs mounts. In this exercise, we will focus on bind mounts.

Bind mounts link a host path to a path in your docker container. You specify bind mounts when you run a container from a docker image:

```{bash}
docker run -d -p 5001:5000 --mount type=bind,source=</absolute/path/to/directory>/results,target=/app/results loud-text
```

## Trying out bind mounts

Before looking at how you can use bind mounts for developing your application,
you can run a quick experiment to get a practical understanding of how bind mounts
work.

First, verify that your `workshop-docker-decrypt` directory is in a directory defined in
Docker Desktop's file sharing setting. This setting defines which parts of your
filesystem you can share with containers. You can check this by clicking Settings (top right) -> Resources -> File sharing.

Next, create a new results folder:

```{bash}
mkdir results
```

Then, run a new loud-text container, mounting the results folder:

```{bash}
docker run -d -p 5001:5000 --mount type=bind,source=<PATH_TO_workshop-docker-decrypt>/results,target=/app/results loud-text
```

:::

The `--mount type=bind` option tells Docker to create a bind mount, where `source` is a path to a location on your host machine, and
`target` is where that directory should appear inside the container.

Next, let's start an interactive bash session to see if the file sharing works:

```{bash}
docker ps #to get container id
docker exec -it <CONTAINER_ID> /bin/sh
ls
```

After running the command, Docker starts an interactive `bash` session in the
root directory of the container's filesystem. Check out the contents. Is the results folder there?

Create a file in the results folder.

```{bash}
cd results
touch some_file.txt
```

Now create a new folder in your container, and create a file in it:

```{bash}
cd ..
mkdir results_2
cd results_2
touch some_other_file.txt
```

Exit the docker container (type `exit` and press enter), and inspect your directory. Can you find the files you created in your container? Why/why not?

## Environment variables

Sometimes, it is important to pass information to a docker container securely, for instance a GitHub access token, or a decryption key. We can do this by passing environment variables when running a docker container:

```{bash}
docker run -d -p 5001:5000 -e <NAME_OF_VARIABLE>=<VALUE_OF_VARIABLE> loud-text
```

e.g.:

```{bash}
docker run -d -p 5001:5000 -e HELLO=WORLD loud-text
```

Now, let's check that the environment variable is accessible in the container:

```{bash}
docker ps #to get the CONTAINER_ID
docker exec -it <CONTAINER_ID> /bin/sh
echo $HELLO
```


## Decode the message

Now, we will integrate everything we have learned about building an image, running a container, mounting directories, and passing environment variables to decode a message. You will work in groups of three. Each of you will:

1. modify your Dockerfile
2. build a new docker image from a Dockerfile
3. run a docker container from your image, passing a decryption key as an environment variable, and mounting a directory for your output.
4. Navigate to the GUI to decode your message, which will be written to your output directory.
5. Send the decoded message to the next member of your group, who will then decode it with their key.

### THE MESSAGE

The message to decode is: bgeeifiih

The message can be decoded sequentially with three different keys, that need to be passed as environment variables.

- Key 1 = good
- Key 2 = bye
- Key 3 = world

### Step 1: Modify your Dockerfile

Before you can start decoding the message, you need to include another dependency in your docker image, as we need a specific Python package for the decoding. Check out app_2.py to identify the dependency you need, and change the requirements.txt file accordingly. Also, we will run app_2.py, not app.py as in the previous exercise. Maybe have a look in the Dockerfile to change that.

### Step 2: Build a new docker image

As before, build a new docker image. Give your image an appropriate name.

### Step 3: Run your docker container

Remember to define a port, mount a folder, and pass the appropriate environment variable. Check what the name of your environment variable should be by inspecting app_2.py. Pass the -d argument to detach.


### Step 4: Navigate to the GUI

Navigate to the GUI in a browser (localhost:PORT). Insert your encoded message (either the message from this tutorial if you are the first decoder, or the decoded message from the previous person in your group otherwise) into the GUI. Press the button. This will write a file to your mounted folder.

### Step 5: Message

You will now find a message.txt file in your mounted directory with a decoded message which still looks gibberish. You need to do this will all three keywords in order to reach the final decoded message.

If you successfully decoded the message, raise your hand and let us know.


## Next steps

We hope you enjoyed the workshop!


