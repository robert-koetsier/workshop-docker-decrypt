---
title: "Decryption app"
author: "BIF buddy group 7"
format: html
execute:
  eval: false
  echo: true
  warning: false
  message: false
toc: true
toc-depth: 3
---

```{r setup, include=FALSE}
# For configuring options
```

# In this exercise you will decode an encrypted message, but before we can do so, we need to learn how to mount the docker directory to your local directory and how to pass environment variables.

# Use bind mounts

In [part 4](05_persisting_data.qmd), you used a volume mount to persist the
data in your database. A volume mount is a great choice when you need somewhere
persistent to store your application data.

A bind mount is another type of mount, which lets you share a directory from the
host's filesystem into the container. When working on an application, you can
use a bind mount to mount source code into the container. The container sees the
changes you make to the code immediately, as soon as you save a file. This means
that you can run processes in the container that watch for filesystem changes
and respond to them.

In this chapter, you'll see how you can use bind mounts and a tool called
[nodemon](https://npmjs.com/package/nodemon) to watch for file changes, and then restart the application
automatically. There are equivalent tools in most other languages and
frameworks.

## Quick volume type comparisons

The following are examples of a named volume and a bind mount using `--mount`:

- Named volume: `type=volume,src=my-volume,target=/usr/local/data`
- Bind mount: `type=bind,src=/path/to/data,target=/usr/local/data`

| Feature | Named Volumes | Bind Mounts |
|----------|----------------|-------------|
| Host location | Docker chooses | You decide |
| Populates new volume with container contents | Yes | No |
| Supports Volume Drivers | Yes | No |

## Trying out bind mounts

Before looking at how you can use bind mounts for developing your application,
you can run a quick experiment to get a practical understanding of how bind mounts
work.

1. Verify that your `getting-started-app` directory is in a directory defined in
Docker Desktop's file sharing setting. This setting defines which parts of your
filesystem you can share with containers. For details about accessing the setting, see [File sharing](../manuals/desktop/settings-and-maintenance/settings.qmd#file-sharing).

> **Note:** The **File sharing** tab is only available in Hyper-V mode, because the files are automatically shared in WSL 2 mode and Windows container mode.

2. Open a terminal and change directory to the `getting-started-app` directory.

3. Run the following command to start `bash` in an `ubuntu` container with a
bind mount.

::: {.panel-tabset}

### Mac / Linux

```{bash}
docker run -it --mount type=bind,src="$(pwd)",target=/src ubuntu bash
```

### Command Prompt

```{bash}
docker run -it --mount "type=bind,src=%cd%,target=/src" ubuntu bash
```

### Git Bash

```{bash}
docker run -it --mount type=bind,src="/$(pwd)",target=/src ubuntu bash
```

### PowerShell

```{bash}
docker run -it --mount "type=bind,src=$($pwd),target=/src" ubuntu bash
```

:::

The `--mount type=bind` option tells Docker to create a bind mount, where `src` is the
current working directory on your host machine (`getting-started-app`), and
`target` is where that directory should appear inside the container (`/src`).

4. After running the command, Docker starts an interactive `bash` session in the
root directory of the container's filesystem.

```{console}
root@ac1237fad8db:/# pwd
/
root@ac1237fad8db:/# ls
bin   dev  home  media  opt   root  sbin  srv  tmp  var
boot  etc  lib   mnt    proc  run   src   sys  usr
```

5. Change directory to the `src` directory. Listing its contents should match
your `getting-started-app` directory on your host machine.

```{console}
root@ac1237fad8db:/# cd src
root@ac1237fad8db:/src# ls
Dockerfile  node_modules  package.json  spec  src  yarn.lock
```

6. Create a new file named `myfile.txt`.

```{console}
root@ac1237fad8db:/src# touch myfile.txt
root@ac1237fad8db:/src# ls
Dockerfile  myfile.txt  node_modules  package.json  spec  src  yarn.lock
```

7. On the host, observe that `myfile.txt` appears in your directory:

```{text}
├── getting-started-app/
│ ├── Dockerfile
│ ├── myfile.txt
│ ├── node_modules/
│ ├── package.json
│ ├── spec/
│ ├── src/
│ └── yarn.lock
```

8. Delete `myfile.txt` from the host, then check the container — it should be gone.

```{console}
root@ac1237fad8db:/src# ls
Dockerfile  node_modules  package.json  spec  src  yarn.lock
```

9. Stop the interactive container session with `Ctrl` + `D`.

This shows how files are shared between the host and container, and how changes
are reflected instantly.

## Development containers

Bind mounts are great for local development setups. The host machine doesn’t
need build tools installed — the container provides them.

### Run your app in a development container

We'll run a container with a bind mount that:

- Mounts your source code
- Installs dependencies
- Starts `nodemon` to watch for file changes

::: {.panel-tabset}

### Mac / Linux CLI

```{bash}
docker run -dp 127.0.0.1:3000:3000   -w /app --mount type=bind,src="$(pwd)",target=/app   node:lts-alpine   sh -c "yarn install && yarn run dev"
```

### PowerShell CLI

```{powershell}
docker run -dp 127.0.0.1:3000:3000 `
-w /app --mount "type=bind,src=$pwd,target=/app" `
node:lts-alpine `
sh -c "yarn install && yarn run dev"
```

### Command Prompt CLI

```{bash}
docker run -dp 127.0.0.1:3000:3000 ^
-w /app --mount "type=bind,src=%cd%,target=/app" ^
node:lts-alpine ^
sh -c "yarn install && yarn run dev"
```

### Git Bash CLI

```{bash}
docker run -dp 127.0.0.1:3000:3000   -w //app --mount type=bind,src="/$(pwd)",target=/app   node:lts-alpine   sh -c "yarn install && yarn run dev"
```

### Docker Desktop

1. Make sure no `getting-started` containers are running.  
2. Open Docker Desktop → **Images** tab → find `getting-started`.  
3. Click **Run**, then **Optional settings**.  
4. Set **Host path** = your `getting-started-app` directory.  
5. Set **Container path** = `/app`.  
6. Click **Run**.

You'll know it's ready when the logs show:

```{console}
nodemon -L src/index.js
[nodemon] starting `node src/index.js`
Using sqlite database at /etc/todos/todo.db
Listening on port 3000
```

:::

### Develop your app with the development container

Update the app on your host and see the changes reflected instantly.

1. In `src/static/js/app.js`, on line 109, change the "Add Item" button text:

```diff
- {submitting ? 'Adding...' : 'Add Item'}
+ {submitting ? 'Adding...' : 'Add'}
```

2. Refresh your browser — the change appears almost immediately.  
![Updated Add button](images/updated-add-button.webp)

3. When done, stop the container and rebuild your image:

```{bash}
docker build -t getting-started .
```

## Summary

You can now persist your database and see code changes in real-time using bind
mounts. Docker also supports other mount types and storage drivers for advanced
use cases.

Related information:

- [docker CLI reference](../reference/cli/docker.qmd)
- [Manage data in Docker](https://docs.docker.com/storage/)


## Decode the message

The message to decode is: bgeeifiih
bgeeifiih is decode with three different keys that need to be passed as environment variables.
Key 1 = good
Key 2 = bye
Key 3 = world

### Update and reinstall docker image

Before you can start decoding the message, you need to update the requirement file as a not yet installed Python package is needed for the decoding. Check out app_2.py and have a look at the requirement.txt file. Also, we don't use app.py but app_2.py in this exercise. Maybe have a look in the Dockerfile to change that.

### How to decode the message

After having a new docker image installed you now should mount your directory to the docker directory and pass the key as an enviroment variable.

```{bash}
docker run -e KEY=yourKey -p 5000:5001 -v your/directory/:/app/results/ -it dockerName
```

You will now find a message.txt file in your directory with a decoded message which still looks gibberish. You need to do this will all three keywords in order to reach the final decoded message. When you successfully decoded the message, raise your hand and let us know.


## Next steps

We hope you enjoyed the workshop!


